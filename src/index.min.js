"use strict";const socketIO=require("socket.io");module.exports={register(){},bootstrap({strapi:strapi}){let interval;var io=socketIO(strapi.server.httpServer,{cors:{origin:"*",methods:["GET","POST"]}});io.use(async(socket,next)=>{try{const result=await strapi.plugins["users-permissions"].services.jwt.verify(socket.handshake.query.token);socket.user=result.id,next()}catch(error){console.log(error)}}).on("connection",(function(socket){interval&&clearInterval(interval),console.log("a user connected"),interval=setInterval(()=>{io.emit("serverTime",{time:(new Date).getTime()})},1e3),socket.on("join",async data_join=>{let params=data_join;const netItem={data:{campaign_id:params.id,address:params.address,publishedAt:new Date}};try{console.log(strapi.service("api::participan.participan"));let data=await strapi.service("api::participan.participan").create(netItem)}catch(error){console.log(error)}}),socket.on("makeBid",async data=>{let params=data;try{let found=await strapi.entityService.findOne("api::product.product",params.product,{fields:"bid_price"});const account=await strapi.service("api::account.account").getUserAccount(socket.user);if(parseInt(account.balance)>=parseInt(found.bid_price)){await strapi.service("api::bid.bid").makeBid({...params,account:account.id});let product=await strapi.service("api::product.product").findAndUpdateBidPrice(found,params.bidValue),updatedProduct=await strapi.service("api::product.product").loadBids(product.id);io.emit("loadBids",updatedProduct)}else console.log("Balance Is low")}catch(error){console.log(error)}}),socket.on("disconnect",()=>{console.log("user disconnected"),clearInterval(interval)})})),strapi.io=io}};